# leetcode-go
leetcode 通过代码-Go语言，记录个人刷题过程



## 如何刷力扣

### 推荐视频

数据结构及算法：[手把手带你刷力扣｜各个击破数据结构和算法](https://www.bilibili.com/video/av800400699)

力扣新手推荐题：[刷完这70道力扣Leetcode题，你就可以出新手村啦](https://www.bilibili.com/video/BV1Cp4y1a79T)



### 刷力扣方法

- 按知识点刷：2简单+2中等
- 刷经典题（Hot 100 / Top 100）
- **不要**按题号顺序刷



### 70道题目

- 1- 数据结构：简单题
- 2- 算法：中等题

| 数据结构         | 题号           |
| ---------------- | -------------- |
| 数组Array        | 485/283/27     |
| 链表Linked List  | 203/206        |
| 队列Queue        | 933/225/622/64 |
| 栈Stack          | 20/496/232     |
| 哈希表Hash Table | 217/389/496    |
| 集合Set          | 217/705        |
| 堆Heap           | 215/692        |
| 树/图            | 各种算法题中   |



| 算法                        | 题号                  |
| --------------------------- | --------------------- |
| 双指针算法Two Pointers      | 141/344/881           |
| 二分查找法Binary Search     | 704/35/162/74         |
| 滑动窗口Sliding Window      | 209/1456              |
| 递归算法Recursion           | 509/206/344/687       |
| 分治算法Divide & Conquer    | 169/53                |
| 回溯算法Backtracing         | 22/78/77/46           |
| 深度优先搜索DFS             | 938/78/200            |
| 宽度优先搜索BFS             | 102/107/200           |
| 并查集Union Find            | 200/547/721           |
| 贪心算法Gready              | 322/1217/55           |
| 记忆化搜索Memorization      | 509/322               |
| 动态规划Dynamic Programming | 509/62/121/70/279/221 |
| 拓扑排序Topologic Sort      | 207/210               |
| 前缀树Trie                  | 208/720/692           |



# 入门 - 按数据结构

## 数组Array

### [力扣485. 最大连续 1 的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)

给定一个二进制数组， 计算其中最大连续 1 的个数。

示例：

```
输入：[1,1,0,1,1,1]
输出：3
解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.
```

> **提示：**
>
> - 输入的数组只包含 0 和 1 。
> - 输入数组的长度是正整数，且不超过 10,000。

#### 方法：一次遍历

**主要思路：**遍历一遍数组，用两个变量`res`和`tmp`，`res`记录当前最大连续 1 的个数，`tmp`记录当前连续 1 的个数。当遇到`0`时，`tmp`置`0`；当遇到`1`时，`tmp++`。更新`tmp`后，比较当前是否`tmp`和`res`的大小，如果`tmp > res`，则更新`res`。

时间复杂度O(n)，空间复杂度O(1)。



### [力扣283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

> 说明:
>
> 必须在原数组上操作，不能拷贝额外的数组。
> 尽量减少操作次数。

#### 方法一：两次遍历/双指针

**主要思路：**不关注`0`所在的位置。我们的最终目标是**将非零元素保持原有顺序移到数组最前**，**末尾部分填充`0`**即可。用两个下标`i`和`j`配合，第一次遍历时，将非零元素移动到`j`的位置，`j++`（`j`是下一个非零元素要移动到的位置，并且记录了非零元素的个数，也是之后填充`0`的起点）。第二次遍历时从`j`位置填充`0`。

![283_1.gif](https://pic.leetcode-cn.com/9669b4ffb158eaeeee6f0cd66a70f24411575edab1ab8a037c4c9084b1c743f5-283_1.gif)

> `i`为待处理的序列的头部，`j`为已处理好的序列的尾部。
>
> 也就是官方题解的**双指针**方法！

时间复杂度: O(n)

空间复杂度: O(1)



#### 方法二：一次遍历

**主要思路：**这里参考了快速排序的思想，快速排序首先要确定一个待分割的元素做中间点 `x` ，然后把所有小于等于 `x` 的元素放到 `x` 的左边，大于 `x` 的元素放到其右边。
这里我们可以用 `0` 当做这个中间点，把不等于 `0` (注意题目没说不能有负数)的放到中间点的左边，等于 `0`的放到其右边。
这的中间点就是 `0` 本身，所以实现起来比快速排序简单很多，我们使用两个指针 `i` 和 `j`，只要 `nums[i]!=0`，我们就交换 `nums[i]` 和 `nums[j]`

![283_2.gif](https://pic.leetcode-cn.com/36d1ac5d689101cbf9947465e94753c626eab7fcb736ae2175f5d87ebc85fdf0-283_2.gif)

> 作者：wang_ni_ma
> 链接：https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/



#### 方法三：队列记录可填充位置x

> 自己想的一种方法，刚开始很自豪，看了leetcode上的其他方法的题解后甘拜下风。其实就是方法一的变种，整复杂了，位置信息是不必要的。

**主要思路：**使用**队列** `queue`记录**可被填充的位置**（索引/下标），如`0`或非零元素移动后留下的位置，变量`count`记录数组中`0`的个数。

当遇到`0`时，将其索引存入队列，并且`count++`；**当遇到非零元素并且队列非空时**，从队列中弹出一个索引，并将非零元素移动到该索引位置；**当遇到非零元素而队列为空时**，将非零元素前移`count`个位置。最后，在末尾`count`个位置上填充`0`。

时间复杂度O(n)，空间复杂度O(n)。



### [力扣27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

给你一个数组 `nums` 和一个值 `val`，你需要**原地**移除所有数值等于`val`的元素，并返回移除后数组的新长度。

- 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。
- 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

#### 方法：双指针

**主要思路**：一次遍历，使用两个指针，一个指针用于遍历，另一个指针指向存放非`val`值的队尾。只需要将不等于`val`的值移到前面即可。当遍历到元素不等于`val`时，将该值移动到非`val`值队尾，非`val`值指针值加一。



## 链表LinkList

### [力扣203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回新的头节点 。

#### 方法一：就地删除

**思路：**依次遍历链表，当遍历到值为`val`的结点时删除。头结点单独处理。

#### 方法二：增加头结点

**思路：**将原链表当做带头结点的链表处理，第一个元素（原本的头结点）不用单独处理。

#### 方法三：递归法



### [力扣206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

解法同《Go面试算法宝典》中反转链表。该处为**不带头结点**的链表逆序

#### 方法一：就地逆序

**思路：**将每个结点的`Next`域指向其前一个结点。需要记录用的有前一个结点`pre`、当前结点`cur`、下一个结点`next`。

#### 方法二：头插法

**思路：**顺序遍历链表，将每个遍历到的**结点插入到**（自己创建的）**头结点后**，就像**栈**一样，先遍历到的结点后出现，完成了逆序

#### 方法三：递归



## 队列Queue

### [力扣933. 最近的请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/)

#### 方法：队列

认真读题，分析示例和解释。理解题意即可正确作答。该题的关键是当新的 `t` 到来时，只保留与它相差 `3000` 以内的 `t`，即当新的`t`入队时，**检查队头的值与其相差是否在 `3000` 以内**，如果超过 `3000` 则将其弹出，最后返回队列中值的个数。



### [力扣225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)
